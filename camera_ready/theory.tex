% !TEX root = main.tex

% \section{Robust Reach-Avoid for Multi-Agent Systems}

 \subsection{Solution Outline}
To solve the decentralized control problem, 
we first plan a high-level nominal trajectory for the product system by ignoring the disturbances, and then synthesize low-level formally verified controllers for robustly tracking the nominal trajectory under worst-case disturbances.
We summarize our approach for solving Prob.~\ref{problem} in Alg.~\ref{alg:main}.
The approach is composed of three main steps:
(1) Synthesize a global open-loop controller for the \emph{nominal system} as a single planner task on the product system to satisfy $\Phi_\varepsilon$;
(2) Project the controller into local controllers and obtain a nominal trajectory for each system; and
(3) Design local closed-loop controllers to track the nominal trajectory while always staying within the robustness margin.
% a given distance of the trajectory.  
The soundness of the technique is summarized below.

\begin{theorem}
Local feedback controllers $\set{C^i}$ synthesized by Alg.~\ref{alg:main} guarantee that the global specification is satisfied by the product system $\set{C^i}\parallel \set{\Sigma^i}$. 
\end{theorem}
\begin{proof}
Note that $\Phi_\varepsilon$ is a stronger version of $\Phi$ and is intentionally made conservative to allow for $\varepsilon$-deviation in the trajectory of the product system.
Since $\set{\rho^i}$ is the unique solution of the nominal product system and satisfies $\Phi_\varepsilon$, it is guaranteed that $\varepsilon$-perturbation of this nominal trajectory satisfies $\Phi$.
It can be observed that all solutions of $\Sigma^i$ stay within distance $\varepsilon^i$ of the nominal trajectory 
$\rho^i$ regardless of the disturbance. 
This completes the proof.
\end{proof}

%The local controllers synthesized by Alg.~\ref{alg:main} is guaranteed to solve Prob.~\ref{problem}.  
%It can be observed that if every  $C^i\parallel \Sigma^i$ can realize $\Phi_\track^i$, then because the simultaneous satisfaction of $\rho^i$-s for every $i$ implies satisfaction of $\Phi_\varepsilon$ by design, and because $\Phi_\varepsilon$ is an $\varepsilon$-robust version of $\Phi$, hence it follows that $\set{C^i}_{i\in [1;N]}\parallel \set{\Sigma^i}_{i\in [1;N]}$ will realize $\Phi$ under the worst-case disturbance.
Next, we discuss some implementation details of Alg.~\ref{alg:main} for the global \emph{open-loop planner} (Step~\ref{step:planning}) and the local \emph{guaranteed trajectory tracking} (Step~\ref{step:tracking}) in our tool \tool. Note that Step~\ref{step:decompose} is a simple projection from the product space into local spaces.
While we instantiate particular techniques, our method can be used with other implementations as well.

\begin{algorithm}[t]
	\caption{Multi-agent Controller Synthesis}
	\label{alg:main}
	\begin{enumerate}
		\item For every $i$, let $\Sigma_{\nom}^i = (X^i,x_\init^i,U^i,\set{0},f^i)$ be the nominal control system of $\Sigma^i$ that ignores the disturbance.
		Compute the product control system $\Sigma^\times_{\nom}$ of $\set{\Sigma^i_{\nom}}$. 
		%Let $\varepsilon\in \mathbb{R}^n_{>0}$ be a robustness margin. %a discussion on $\varepsilon$ follows subsequently.
		Use a scalable \emph{planner} to compute a nominal open-loop controller $C^\times_{\nom}:[0;T]\rightarrow U^\times$ such that the specification $\Phi_\varepsilon$ is satisfied by $C^\times_\nom\triangleright\Sigma_{\nom}^{\times}$.
		Note that $T$ is the first time the set $\goal'$ is visited. \label{step:planning}
		\item Decompose $C^\times_\nom$ into \emph{local} open-loop controllers $\set{C^i_\nom}$ for the set of $\set{\Sigma^i_{\nom}}$ by projecting the output of $C^\times_\nom$ into local input spaces $U^i$.
		%The decomposition is straightforward since $C^\times_\nom$ is open-loop.
		Further, for every $i$, find the unique nominal open-loop trajectory $\rho^i=(x_{0,\nom}^i,\ldots,x_{T,\nom}^i)$ of $C^i_\nom\triangleright \Sigma_{\nom}^i$. These trajectories are unique since there is no disturbance. \label{step:decompose}
		\item Let $\varepsilon^i\in \mathbb{R}^{n_i}_{>0}$, $i\in[1;N]$, be the projections of $\varepsilon$ compatible with the state dimensions of $\Sigma^i$.
		Each control system $\Sigma^i$ uses a \emph{guaranteed tracking} method to compute a closed-loop controller $C^i$ such that $C^i\parallel \Sigma^i$ \emph{tracks} the nominal trajectory $\rho^i$ and stays within its $\varepsilon^i$-neighborhood, i.e., $C^i\parallel \Sigma^i$ satisfies the specification
		\begin{align}
			\label{eq:ltl_spec}
			\Phi_{\track}^i\coloneqq \bigwedge_{k\in [0;T]} \bigcirc^k \ball_{\varepsilon^i}(x_{k,\nom}^i).
		\end{align}
		%where %$\bigcirc$ denotes the next operator in LTL (\cite{baier2008principles}) and
		%$\bigcirc^t$ represents the juxtaposition of $t$ consecutive ``$\bigcirc$'' operators.
		\label{step:tracking}
	\end{enumerate}
\end{algorithm}

%We did not yet mention the role of the robustness margin $\varepsilon$.
%Essentially, $\varepsilon$ accounts for the possible tracking error of the ABCD-generated controller in Step~\ref{step:abcd} while tracking the nominal trajectory.
%Because ALTRO ignores the disturbances, hence a positive tracking error is inevitable.
%For this reason, if we choose $\varepsilon$ too small, then it will be more difficult for ABCD to find a controller against the worst case disturbances, and we might not be able to obtain a controller in Step~\ref{step:abcd} in the end.
%On the other hand, if we choose $\varepsilon$ too large, then it will be more difficult for ALTRO to find a nominal open-loop controller in the first place.
%So ideally, in Step~\ref{step:altro}, we should maximize $\varepsilon$ so that an open-loop controller can be obtained by ALTRO for $\Phi_\varepsilon$.
%For this work, we did not implement this step in an algorithmic manner, and relied on the judgment of the system designer for choosing a suitable $\varepsilon$.



%\subsection{Linear Temporal Logic for Control Specification}
%
%We will use Linear Temporal Logic (LTL) for specifying control tasks; we refer to usual references \cite{baier2008principles} for detailed syntax and semantics of LTL.
%Given a pair of predicates $p$ and $q$, as usual, we will use the notation 
%$\lnot p$ for \emph{negation} of $p$, 
%$p\vee q$ for $p$ \emph{or} $q$,
%$p\wedge q$ for $p$ \emph{and} $q$,
%$\bigcirc p$ for \emph{next} $p$,
%$p\; \mathcal{U}\; q$ for $p$ \emph{until} $q$,
%$\square p$ for \emph{always} $p$,
%$\lozenge p$ for \emph{eventually} $p$.
%
%We also define a robust version of LTL formulae.
%Suppose $\Psi$ be an LTL formula defined using a set of predicates on $\mathbb{R}^n$ for some $n>0$.
%Let $\epsilon\in \mathbb{R}^n_{>0}$ be a given \emph{robustness margin}.
%Let $\rho=(x_0,x_1,\ldots)$ be an infinite sequence of elements from $\mathbb{R}^n$.
%Define the $\epsilon$-neighborhood of $\rho$ as the set of infinite sequences $\rho_\epsilon\coloneqq \set{(x_0',x_1',\ldots) \mid \forall i\in \mathbb{N}\;.\; x_i'\in \Omega_\epsilon(x_i)}$.
%Then we define $\Psi_\epsilon$ as an LTL formula such that for every sequence $\rho=(x_0,x_1,\ldots)$, if $\rho$ satisfies $\Psi_\epsilon$, then every sequence $(x_0',x_1',\ldots)$ in $\rho_\epsilon$ satisfies $\Psi$.
%In practice, we obtain $\Psi_\epsilon$ from $\Psi$ by strengthening the predicates which were used to define $\Psi$: 
%For example, if $\Psi = \square S$ for a set $S\subseteq \mathbb{R}^n$, then $\Psi_\epsilon = \square S'$ with $S' = S \ominus \Omega_\epsilon(0)$ being the strengthening of $S$, where ``$\ominus$'' denotes the Minkowski difference of two sets.
%
%Given a control system $\Sigma$, an open-loop (a feedback) controller $C$ of the sampled-time abstraction $\Sigma_\tau$ of $\Sigma$, and an LTL specification $\Phi$ defined over a set of predicates over the state space of $\Sigma$, we will say that $C\triangleright \Sigma_\tau$ ($C\parallel \Sigma_\tau$) realizes $\Phi$ if every trajectory in the set $\Beh^\ol(x_\init)$ ($\Beh^\cl(x_\init)$) satisfies $\Phi$.
%
%Likewise, given $\set{\Sigma_\tau^i} $, a set of open-loop (feedback) controllers $\set{C^i} $, and an LTL specification $\Phi$ defined using a set of predicates over the state space of $\Sigma^\times$, we will say that decentralized open-loop (decentralized closed-loop) realizes $\Phi$ if every trajectory of $\set{C^i}\triangleright \set{\Sigma_\tau^i}$ ($\set{C^i}\parallel \set{\Sigma_\tau^i}$) satisfies $\Phi$.


%We use a combination of methods to solve the problem.
%First, we quickly obtain a \emph{global} controller $C^\times$ for the product control system $\Sigma^\times_\tau$ using the fast and scalable tool, called ALTRO.
%In principle, any other fast method, suitable for large systems, can be used for this stage.
%ALTRO does not support disturbances, and so we ignore it in this stage.
%ALTRO give us a rough open-loop controller $C^\times$ for the product system $\Sigma^\times$.
%Second, thanks to the decentralized control architecture, we can easily decompose $C^\times$ into nominal local controllers $\set{C^i_\nom}$ for the individual robots.
%The set of controllers $\set{C^i_\nom}$ are actually used as a set of initial guesses for the 
%In the lower level, we rigorously obtain \emph{local} controllers $\set{C^i}$ using ABCD, to track---with formal guarantees against the disturbances---the intended nominal trajectories.
%
%In the lower level, we use ABCD to synthesize a controller that will track the nominal trajectory

%Now we present some optimization for Step~\ref{step:abcd} of Alg.~\ref{alg:main} that significantly improved the computation time.

%\subsection{Optmization: Local ABCD around the nominal trajectory}\label{sec:local_abcd}
%Usually, in ABCD the abstraction process requires computation of abstract transitions all over the state space, which is computationally expensive.
%Luckily, for Step~\ref{step:abcd} of Alg.~\ref{alg:main}, we only need to compute transitions in the $\varepsilon$-neighborhood of the given nominal trajectory.
%We summarize our optimized approach for Step~\ref{step:abcd} in Algorithm~\ref{alg:abcd-with-time-for-tracking}.
%For simpler notation, we omit the robot index $i$.
%Given a robot's model as a control system $\Sigma$, together with a reference open-loop trajectory satisfying $\Phi_\varepsilon$ and a tube size $\varepsilon\in \reals_{>0}^n$, we iteratively construct a tube $P$ as union of $\varepsilon$-balls around the reference trajectory's points. 
%Next, we compute finite state abstraction for $\Sigma$ setting $Domain=P$ and for the chosen parameters $\eta_x$, $\eta_u$ and $\tau$. 
%Finally, Given the computed finite state abstraction $\widehat \Sigma$ and the LTL specification in Eq.~\eqref{eq:ltl_spec}, we synthesize controller using usual ABCD, implemented using SCOTS. %\MS{perhaps we can add a discussion here about our actual implementation.}
%
%We use Alg.~ \ref{alg:abcd-with-time-for-tracking} for solving Prob.~\ref{prob:tracking_with_time} using finite abstraction.
% It means we embedding extra state variable, which represents time. Here we use notation $\Psi_\epsilon(\widetilde{x})$ which is very similar to $\ball_\varepsilon(x)$.
%$\Psi_\epsilon$ denotes the ball radius $\varepsilon$ centered around $X$ and radius zero for time $t$.
%Formally:\\ $\Psi_\epsilon(\widetilde{x}=\begin{bmatrix} x \\t \end{bmatrix}):= \set{\widetilde{x}'=\begin{bmatrix}
%	x' \\
%	t'
%	\end{bmatrix}
%	\in \widetilde{X}\mid  \| x-x' \|\leq \varepsilon \land (t=t')}$\\
%we are using Alg \ref{alg:abcd-with-time-for-tracking} for solving Prob \ref{prob:tracking_with_time} using finite abstraction



%Alg.~\ref{alg:abcd-for-tracking} outlines the steps for solving Prob.~\ref{prob:tracking} using finite state abstraction.



%\subsection{Some ALTRO-specific implementation details}

%In the following, we summarize some ALTRO-specific implementation details.

\subsection{Open-loop Planning}
The planner used for generating nominal trajectories in Step~\ref{step:planning} of our algorithm should be fast and scalable. In addition, it should be capable of handling non-linear dynamics and constraints. Our choice for the planner is ALTRO \cite{howell2019altro}. ALTRO is a fast and numerically robust solver for constrained trajectory optimization problems and and is capable of handling nonlinear state and input constraints. Given a product system $\Sigma_{\nom}^\times$, reach-avoid specification $\Phi_\varepsilon$ and time horizon $T$, ALTRO computes an open-loop controller $C^\times_{\nom}:[0;T]\rightarrow U^\times$ by solving the optimization
\begin{equation*}
	\begin{aligned}
		& \underset{u^\times_0,u^\times_1,\ldots,u^\times_T}{\text{minimize}}
		& & \ell_T(x^\times_T)+\sum_{k=0}^{T-1}\ell_k(x^\times_k,u^\times_k) \\
		& \text{subject to}
		& & x^\times_{k+1}=f^\times(x^\times_k,u^\times_k),\,\,\,\forall k\in[0;T-1]\\
		& & &  g(x^\times_k,u^\times_k)\leq 0, \qquad\forall k\in[0;T]\\
		& & &  h(x^\times_k,u^\times_k)=0,\qquad\forall k\in[0;T],
	\end{aligned}
\end{equation*}
where $\ell_k(\cdot,\cdot)$ denotes a quadratic objective function assigning cost to each pair of state and input before the end of horizon, $\ell_T(\cdot)$ represents a quadratic objective function assigning penalty to the final state $x^\times_T$ being away from the goal set $\goal'$. The constraints $g(x^\times_k,u^\times_k)\leq 0$ and $h(x^\times_k,u^\times_k)=0$ capture the requirement that at each time $k$ the state should not be in $\avoid'$, the state $x^\times_T$ should be in $\goal'$, and the input $u^\times_k$ should always be in $U^\times$.
%
In multi-robot scenarios, the inequality constraints can be used to define collision and obstacle avoidance specifications and the equality constraints can define fixed formation specification. 
Note that the reach-avoid specification is fulfilled if the corresponding equality and inequality constraints (i.e., $g(\cdot)\leq 0$, $h(\cdot)=0$) are satisfied at every time-step and thus choice of the quadratic objective function ($\ell_k$ for $k\in[0;T]$) is not crucial.
%Following step~\ref{step:decompose} of Alg.~\ref{alg:main}, we get open-loop nominal trajectories $\rho^i$ for every agent.

\begin{remark}
	ALTRO supports only bounded horizon control problem.
	For this reason, we model the states in $\goal'$ as a sink state and select a time horizon $T$ for solving the planning task on the nominal product system. We increase the horizon $T$ if ALTRO is not able to find a controller.
	%we were forced to specify a horizon while solving the synthesis problem in Step~\ref{step:planning} of Alg.~\ref{alg:main}.
	We stress that this is an ALTRO-specific implementation detail, and our overall method does not rely on a fixed time horizon.
\end{remark}



\subsection{Guaranteed Trajectory Tracking} 

Trajectories computed in the planning stage might not be followed in the presence of disturbance and therefore we need to use a 
formally guaranteed tracking controller to satisfy the given reach-avoid specification. 
Our choice for this purpose is the so-called abstraction-based controller design (ABCD). 
ABCD can handle nonlinear dynamics, (bounded) uncertainties and $\omega$-regular specifications. In particular, we use the tool called SCOTS~\cite{Rungger2016scots} 
for implementing ABCD. Next, we introduce briefly the basics of ABCD.
For simpler notation, we omit the control system index $i$ in the rest of this section.

% \subsubsection{Preliminaries of Abstraction-Based Controller Design}\hfill

\smallskip
\noindent\textbf{Finite-state Abstraction of Control Systems.}\
Let $\Sigma = (X,x_\init, U, W, f)$ be a control system and $\bound$ be a subset of $X$ which imposes a safety specification on all possible trajectories of the system. Let $\Xh$ be a given \emph{finite partition} of $\bound$, and $\Uh$ be a \emph{finite subset} of equally spaced (w.r.t.\ infinity norm on $\mathbb{R}^m$) points in the input set $U$.
%Note that, since $X$ is unbounded, hence some partition element of $\Xh$ will inevitably be unbounded set.
A \emph{finite-state abstraction} of $\Sigma$ is a finite state-transition system $(\Xh,\Uh,\fh)$, where $\xh'$ is in $\fh(\xh,u)$ if there is a pair of states $x\in \xh$ and $x'\in \xh'$ such that $x'\in \Sol_\Sigma(x,u)$.

In this work, we will use uniformly sized rectangular partition elements to construct the set $\Xh$ from the set $\bound$.
Without going into the detail of the construction, we assume that the size of the partition elements is provided as a vector $\eta_x\in \mathbb{R}^n_{>0}$ which is an input to the abstraction procedure.
Note that, the larger $\eta_x$ is (where comparison is made dimension-wise), the smaller is the state space $\Xh$ resulting in an efficient computation.
On the other hand, the smaller $\eta_x$ is, the better is the precision of the abstraction $\widehat{\Sigma}$ increasing the chance of a successful controller synthesis. Similar to the state space partition size $\eta_x$, we also assume that the set $\Uh$ is chosen based on an input space discretization parameter $\eta_u\in \mathbb{R}^m_{>0}$ that governs the distance between the points in $\Uh$.

%\smallskip
%\noindent\textbf{An Additional Safety Restriction.}\
%When the state space of the control system is open or unbounded and the trajectories in \eqref{equ:def_f} are allowed to grow in an unbounded fashion, a finite-state abstraction, in a sense that is going to be formalized soon, will be technically infeasible.
%So we impose an additional restriction that the system should always remain inside a compact subset of states $\bound$, which is determined according to some known bounds on the state variables.
%This is a standard practice in the literature \cite{reissig2016feedback}, and we will implicitly assume that if there is a tracking controller for Prob.~\ref{prob:tracking_with_time}, then there is a tracking controller for Prob.~\ref{prob:tracking_with_time} with the additional safety requirement $\square \bound$.
%
% a given reach-avoid specification \eqref{eq:spec}, then $C$ also realizes the following modified specification:
%\begin{equation}\label{eq:modified spec}
%	x_0 \wedge ([\bigwedge_{1\leq i\leq N}D(x^i,\obs)>\delta_{obs}\; \bigwedge_{1\leq i,j\leq N\;i\neq j}  d(x^i,x^j)>\delta_{\col}]\; \mathcal{U}\;\reach) \wedge \square \bound.
%\end{equation}

\smallskip
\noindent\textbf{Feedback Refinement Relation.}\
Let $\Sigma$ be a control system and $\widehat{\Sigma}$ be its finite-state abstraction.
A \emph{feedback refinement relation} (FRR) from $\Sigma$ to $\widehat{\Sigma}$ 
is a relation $Q\subseteq \bound\times \Xh$ s.t.\ 
for all $x\in \bound$ there is some $\xh\in \Xh$ such that $Q(x,\xh)$ and
for all $(x,\xh)\in Q$, we have
\begin{inparaenum}[(i)]
	\item $\Uh_{\widehat{\Sigma}}(\xh)\subseteq U_{\Sigma}(x)$, and 
	\item $u\in U_{\widehat{\Sigma}}(\xh) \Rightarrow Q(f(x,u))\subseteq \fh(\xh,u)$,
\end{inparaenum}
where $U_{\Sigma}(x):=\set{u\in U \mid f(x,u)\neq \emptyset}$ and $\Uh_{\widehat{\Sigma}}(\xh):=\set{u\in \Uh \mid \fh(\xh,u)\neq \emptyset}$.
We write $\Sigma \frr{Q} \widehat{\Sigma}$ if $Q$ is an FRR from $\Sigma$ to $\widehat{\Sigma}$.

\smallskip
\noindent\textbf{Abstraction-based Controller Design.}\
The abstraction-based controller design (ABCD) \cite{reissig2016feedback} is a $3$-step method to find a robust controller for the control system $\Sigma$:
First, we compute a finite state abstraction $\widehat{\Sigma}$ s.t.\ $\Sigma \frr{Q} \widehat{\Sigma}$.
Second, we synthesize an abstract controller of the form $\widehat{C}:\Xh\rightarrow \Uh$ for $\widehat{\Sigma}$ using methods from the reactive synthesis literature.
Finally, we obtain the desired controller $C$ as $C:=\widehat{C}\circ Q$.
It is known that this three step process produces a feedback controller $C$ such that $C\parallel \Sigma$ satisfies the specification \cite{reissig2016feedback}.

If a controller cannot be found, we reduce the discretization parameters $\eta_x$ and $\eta_u$ and try again,
or use a larger robustness margin $\varepsilon$.

% \smallskip
% \noindent\textbf{Computation of the Finite-State Abstraction.}\
% We assume that there is a black-box procedure named $\findAbs$ which takes as input the description of $\Sigma = (X,x_\init,U,W,f)$, a compact subset $\bound$ of the set $X$ and discretization parameters $\eta_x$ and $\eta_u$, and returns a finite-state abstraction $\widehat{\Sigma} = (\Xh,\Uh,\fh)$ of $\Sigma$ and a relation $Q$ s.t.\ $\Sigma\frr{Q} \widehat{\Sigma}$.
% An implementation of $\findAbs$ can be found in \cite{reissig2016feedback}.



\smallskip
\noindent\textbf{Optmization: Local ABCD around the nominal trajectory.}\
%
The abstraction process of ABCD usually requires computation of abstract transitions over the whole compact set $\bound$, which is computationally expensive.
Luckily, for Step~\ref{step:tracking} of Alg.~\ref{alg:main}, we only need to compute transitions in the $\varepsilon$-neighborhood of the given nominal trajectory.
%We summarize our optimized approach for Step~\ref{step:tracking} in Algorithm~\ref{alg:abcd-with-time-for-tracking}.
Given a control system $\Sigma$, together with a reference open-loop trajectory $\rho=(x_{0,\nom},\ldots,x_{T,\nom})$ and a tube size $\varepsilon\in \reals_{>0}^n$, we iteratively construct a tube as union of $\varepsilon$-balls around the reference trajectory (note that we have omitted  the system index $i$ for simpler notation).
Next, we compute finite state abstraction for $\Sigma$ for the chosen parameters $\eta_x$, $\eta_u$ by setting
\begin{equation*}
\bound\coloneqq\bigcup_{k=0}^T\ball_{\varepsilon}(x_{k,\nom}).
\end{equation*}
%
In practice, this local computation of the abstraction is the key to scalability.
\begin{remark}
Our decentralized controller synthesis approach features an interplay between the global open-loop planning and local formal synthesis via the robustness parameter $\varepsilon$ and the discretization parameters $\eta_x,\eta_u$.  The parameter $\varepsilon$ should be large enough to allow deviation from the nominal trajectory caused by the disturbance. A small $\varepsilon$ makes the local specification $\Phi^i_{track}$ very strong for the ABCD synthesis thus requiring large computational complexity with smaller discretization parameters $\eta_x,\eta_u$. On the other hand, large $\varepsilon$ makes the specification $\Phi_\varepsilon$ very conservative or infeasible for the global open-loop planning. Therefore, appropriate parameters should be selected iteratively for successful application of our synthesis approach. 
\end{remark}
% 
% Finally, given the computed finite state abstraction $\widehat \Sigma$ and the specification in Eq.~\eqref{eq:ltl_spec}, we synthesize a symbolic controller using ABCD implemented in SCOTS~\cite{Rungger2016scots}. %\MS{perhaps we can add a discussion here about our actual implementation.}

%We use Alg.~ \ref{alg:abcd-with-time-for-tracking} for solving Prob.~\ref{prob:tracking_with_time} using finite abstraction.

%We did not yet mention the role of the robustness margin $\varepsilon$.
%Essentially, $\varepsilon$ accounts for the possible tracking error of the ABCD-generated controller in Step~\ref{step:planning} while tracking the nominal trajectory.
%Because ALTRO ignores the disturbances, hence a positive tracking error is inevitable.
%For this reason, if we choose $\varepsilon$ too small, then it will be more difficult for ABCD to find a controller against the worst case disturbances, and we might not be able to obtain a controller in Step~\ref{step:tracking} in the end.
%On the other hand, if we choose $\varepsilon$ too large, then it will be more difficult for ALTRO to find a nominal open-loop controller in the first place.
%So ideally, in Step~\ref{step:planning}, we should maximize $\varepsilon$ so that an open-loop controller can be obtained by ALTRO for $\Phi_\varepsilon$.
%For this work, we did not implement this step in an algorithmic manner, and relied on the judgment of the system designer for choosing a suitable $\varepsilon$.

% \begin{algorithm}
% 	\caption{ABCD-for-tracking}
% 	\label{alg:abcd-with-time-for-tracking}
% 	\begin{algorithmic}[1]
% 		\Require $\Sigma=(X,x_\init,U,W,f)$, $\tau \in \mathbb{R}_{>0}$, $\eta_x\in \mathbb{R}^n_{>0}$, $\eta_u\in \mathbb{R}^m_{>0}$, $(x_{0,\nom},\ldots,x_{T,\nom})$, $\varepsilon \in \mathbb{R}_{>0}^{n}$
% 		\Ensure Feedback controller $C\colon X\times[0;T]\to U$ (partial function)
% 		\State $Domain \gets \bigcup_{t=0}^T\ball_{\varepsilon}(x_{t,\nom})$
%% 		\For{$t$ from $0$ to $T$}
%% 		\State $P \gets \ball_{\varepsilon}(x_{t,\nom})$
%% 		\EndFor
% 		\State $(\widehat{\Sigma},Q) \gets \findAbs(\Sigma, Domain, \tau, \eta_{x} , \eta_u)$
% 		\State Synthesize controller $\widehat{C}$ for $\widehat{\Sigma}$ and the specification in Eq. \eqref{eq:ltl_spec} %$(\ball_{\varepsilon}(x_K^\nom,k), \emptyset, (x_0^\nom,0))$
% 		\State \Return $\widehat{C}\circ Q$
% 	\end{algorithmic}
% \end{algorithm}


\subsection{Hybrid vs Geometric Planning}
	
Note that Step~\ref{step:tracking} of Alg.~\ref{alg:main} does not use the nominal controller obtained in Step~\ref{step:planning} and requires only the nominal trajectories.
Then one could argue that, instead of using ALTRO to generate nominal trajectories, a fast \emph{geometric planner} \cite{Kavraki1996rrt} can be employed to generate geometric plans.
However, fast geometric planners do not usually take into consideration the dynamics and control constraints. In our experience, the plans for nominal trajectories generated while ignoring the system dynamics are often untrackable unless the underlying system has special properties (e.g., differential flatness \cite{Murray95differentialflatness}).
This is especially true for systems with restricted control capabilities or under-actuated systems.
We demonstrate this phenomenon on a control system $\Sigma$ that is a simple $2$-dimensional pendulum with the following nominal dynamics:
	\begin{align*}
		\dot{x}_1 = x_2\quad
		\dot{x}_2 = -\sin(x_1) + u/5,
	\end{align*}
where $x_1$ represents the angle (in Radian) of the pendulum rod measured counter-clockwise from the vertical upright position, and $x_2$ represents the rate of change of $x_1$ or the angular velocity.
\begin{wrapfigure}{r}{0.2\textwidth}
		\includegraphics[width=0.2\textwidth]{figures/inv_final.eps}
		\caption{The nominal trajectory (the blue spiral) for the inverted pendulum, the initial state is the red point, and the final state is the green point. \KM{Mehrdad: can you increase the fontsize so that they can be read even when we make the figure small?}} %\Sadegh{Text inside the figure is very small, make it larger so that it is readable.}}
		\label{fig:traj 2d pendulum}
	\end{wrapfigure}
Suppose the initial state of the pendulum is $(\pi,0)$, i.e., when the pendulum is in the vertical downward position and is stationary.
Suppose we want to find a controller for the goal $\goal = \set{(0,0)}$, i.e., when the pendulum is in the vertical upward position and is stationary.
The set of unsafe states $\avoid$ is empty, i.e., no safety constraint is imposed.
When we use ALTRO to compute an open-loop controller $C$, unsurprisingly, the controlled trajectory of $C\triangleright \Sigma$ looks like a spiral, as shown in Fig.~\ref{fig:traj 2d pendulum}.
The synthesis of tracking controller using ABCD is indeed successful when we feed this nominal trajectory to our ABCD solver.
However, if we use a geometric planner for this example that ignores the dynamics, the nominal trajectory would be a straight line path from $(\pi,0)$ to $(0,0)$, which gives an infeasible tracking problem for ABCD, due to the restrictions on possible trajectories of the pendulum coming from the its dynamics.
	
