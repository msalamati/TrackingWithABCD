%! TEX ROOT = ./main.tex
\section{The Solution Outline}

%We use a combination of methods to solve the problem.
%First, we quickly obtain a \emph{global} controller $C^\times$ for the product control system $\Sigma^\times_\tau$ using the fast and scalable tool, called ALTRO.
%In principle, any other fast method, suitable for large systems, can be used for this stage.
%ALTRO does not support disturbances, and so we ignore it in this stage.
%ALTRO give us a rough open-loop controller $C^\times$ for the product system $\Sigma^\times$.
%Second, thanks to the decentralized control architecture, we can easily decompose $C^\times$ into nominal local controllers $\set{C^i_\nom}$ for the individual robots.
%The set of controllers $\set{C^i_\nom}$ are actually used as a set of initial guesses for the 
%In the lower level, we rigorously obtain \emph{local} controllers $\set{C^i}$ using ABCD, to track---with formal guarantees against the disturbances---the intended nominal trajectories.
%
%In the lower level, we use ABCD to synthesize a controller that will track the nominal trajectory

We use the following three-step approach to algorithmically solve the posed problem:

\begin{enumerate}
	\item For every $i$, let $\Sigma_{\tau,\nom}^i = (X^i,x_\init^i,U^i,\set{0},f^i,Y,h^i)$ be the respective \emph{nominal} control system that ignores the disturbances.
			Compute the product control system $\Sigma^\times_{\tau,\nom}$ of $\set{\Sigma^i_{\tau,\nom}}$. 
			Use ALTRO to compute an open-loop controller $C^\times_{\nom}$ for $\Sigma^\times_{\tau,\nom}$ so that $C^\times_\nom\triangleright\Sigma_{\tau,\nom}^{\times}$ realizes  $\Phi$.
			Let $T$ be the time horizon when $\Phi$ has been fulfilled for the first time.
	\item Decompose $C^\times_\nom$ into local open-loop controllers $\set{C^i_\nom}$ for the set of sampled-time abstractions $\set{\Sigma^i_{\tau,\nom}}$.
	\item For every $i$, find the unique open-loop trajectory $\rho=(x_{0,\nom},\ldots,x_{T,\nom})$ of length $T$ of $C^i_\nom\triangleright \Sigma_{\tau,\nom}^i$---unique, because there is no disturbance.
			Use ABCD to find a closed loop controller $C^i$ for $\Sigma_{\tau}^i$ so that $C^i\parallel \Sigma_\tau^i$ realizes the following specification:
			\begin{align}
				\label{eq:ltl_spec}
				\Psi_{\track}\coloneqq \ball_\varepsilon(x_{0,\nom}) \wedge \bigwedge_{k\in [1;T]} \bigcirc^t \ball_\varepsilon(x_{k,\nom}),
			\end{align}
			where $\bigcirc^t$ represents the juxtaposition of $t$ consecutive ``$\bigcirc$'' operators.
\end{enumerate}
\todo{Talk about $\epsilon$}

\subsection{Optmization: Local ABCD around the nominal trajectory}
It is not difficult to see that we only need to compute transitions in the $\varepsilon$-neighborhood of the given nominal trajectory.
Algorithm~\ref{alg:abcd-with-time-for-tracking} summarizes our solution for synthesizing robust feedback controllers for every single robot. 
Given a robot's model as a control system ($\Sigma$), together with a reference open-loop trajectory satisfying Eq.~\eqref{eq:spec} and a tube size $\varepsilon\in \reals_{>0}^n$, we iteratively construct a tube $P$ as union of $\varepsilon$-balls around the reference trajectory's points. 
Next, we compute finite state abstraction for $\Sigma$ setting $Domain=P$ and for the chosen parameters $\eta_x$, $\eta_u$ and $\tau$. 
Finally, Given the computed finite state abstraction $\hat \Sigma$ and the LTL specification in Eq.~\eqref{eq:ltl_spec}, we synthesize controller using SCOTS. \MS{perhaps we can add a discussion here about our actual implementation.}

We use Alg.~ \ref{alg:abcd-with-time-for-tracking} for solving Prob.~\ref{prob:tracking_with_time} using finite abstraction.
% It means we embedding extra state variable, which represents time. Here we use notation $\Psi_\epsilon(\widetilde{x})$ which is very similar to $\ball_\varepsilon(x)$.
%$\Psi_\epsilon$ denotes the ball radius $\varepsilon$ centered around $X$ and radius zero for time $t$.
%Formally:\\ $\Psi_\epsilon(\widetilde{x}=\begin{bmatrix} x \\t \end{bmatrix}):= \set{\widetilde{x}'=\begin{bmatrix}
%	x' \\
%	t'
%	\end{bmatrix}
%	\in \widetilde{X}\mid  \| x-x' \|\leq \varepsilon \land (t=t')}$\\
%we are using Alg \ref{alg:abcd-with-time-for-tracking} for solving Prob \ref{prob:tracking_with_time} using finite abstraction



%Alg.~\ref{alg:abcd-for-tracking} outlines the steps for solving Prob.~\ref{prob:tracking} using finite state abstraction.

\begin{algorithm}
	\caption{ABCD-for-tracking}
	\label{alg:abcd-with-time-for-tracking}
	\begin{algorithmic}[1]
		\Require $\Sigma=(X,U,W,f,Y,h)$, $\tau \in \mathbb{R}_{>0}$, $\eta_x\in \mathbb{R}^n_{>0}$, $\eta_u\in \mathbb{R}^m_{>0}$, $(x_{0_\nom},\ldots,x_{K_\nom})$, $\varepsilon \in \mathbb{R}_{>0}^{n}$
		\Ensure Feedback controller $C\colon X\times [0;K]\to U$ (partial function)
		\State $P \gets \emptyset$
		\For{$k$ from $0$ to $K$}
		\State $P \gets \ball_{\varepsilon}(x_k^\nom)$
		\EndFor
		\State $(\widehat{\Sigma},Q) \gets \findAbs(\Sigma, P, \tau, \eta_{x} , \eta_u)$
		\State Synthesize controller $\widehat{C}$ for $\widehat{\Sigma}$ and the specification given in Eq. \eqref{eq:ltl_spec} %$(\ball_{\varepsilon}(x_K^\nom,k), \emptyset, (x_0^\nom,0))$
		\State \Return $\widehat{C}\circ Q$
	\end{algorithmic}
\end{algorithm}

\subsection{Some implementation details}

\subsubsection{ALTRO vs. geometric planners}

\subsubsection{Bounded horizon reachability}

\subsubsection{Safety margins}

%\section{Various Multi-Robot Tasks in Our Framework}
%
%The basic proble


